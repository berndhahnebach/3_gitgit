
// This file is generated by src/Tools/generateTemaplates/templateClassPyExport.py out of the .XML file
// Every change you make here get lost at the next full rebuild!
#ifndef BASE_BASECLASSPY_H
#define BASE_BASECLASSPY_H

#include <Base/PyObjectBase.h>

namespace Base
{

class BaseClass;

//===========================================================================
// BaseClassPy - Python wrapper
//===========================================================================

/** The python export class for BaseClass
 */
class BaseExport BaseClassPy : public Base::PyObjectBase
{
 public:														
  static PyTypeObject   Type;									
  static PyMethodDef    Methods[];								
  static PyGetSetDef    GeterSeter[];								
  static PyParentObject Parents[];								
  virtual PyTypeObject *GetType(void) {return &Type;};			
  virtual PyParentObject *GetParents(void) {return Parents;}

public:
	BaseClassPy(BaseClass *pcBaseClassObject, PyTypeObject *T = &Type);
	static PyObject *PyMake(PyObject *, PyObject *);
	~BaseClassPy();


	virtual PyObject *_repr(void);  				      // the representation

	/** @name callbacks and implementer for the python object methods */
	//@{
	/// callback for the isDerivedFrom() method
	static PyObject * staticCallback_isDerivedFrom (PyObject *self, PyObject *args, PyObject *kwd);
	/// implementer for the isDerivedFrom() method
	PyObject*  isDerivedFrom(PyObject *args);
	/// callback for the getAllDerivedFrom() method
	static PyObject * staticCallback_getAllDerivedFrom (PyObject *self, PyObject *args, PyObject *kwd);
	/// implementer for the getAllDerivedFrom() method
	PyObject*  getAllDerivedFrom(PyObject *args);
	//@}

	
	/** @name callbacks and implementer for the python object methods */
	//@{
	///geter callback for the Type attribute
	static PyObject * staticCallback_getType (PyObject *self, void *closure);
	/// geter for the Type attribute
	Py::String getType(void) const;
	/// seter callback for the Type attribute
	static int staticCallback_setType (PyObject *self, PyObject *value, void *closure);
	// no seter methode,  Type is read only!
	///geter callback for the Module attribute
	static PyObject * staticCallback_getModule (PyObject *self, void *closure);
	/// geter for the Module attribute
	Py::Int getModule(void) const;
	/// seter callback for the Module attribute
	static int staticCallback_setModule (PyObject *self, PyObject *value, void *closure);
	// no seter methode,  Module is read only!

	/// getter methode for special attributes (e.g. dynamic ones)
	PyObject *getCustomAttributes(const char* attr) const;
	/// setter for special attributes (e.g. dynamic ones)
	int setCustomAttributes(const char* attr, PyObject *obj);
	PyObject *_getattr(char *attr);					      // __getattr__ function
	int _setattr(char *attr, PyObject *value);		// __setattr__ function
	//@}

	/// getter for the object handled by this class
	BaseClass *getBaseClassObject(void) const;
};

#define PARENTSBaseClassPy &BaseClassPy::Type,PARENTSPyObjectBase

}  //namespace Base

#endif  // BASE_BASECLASSPY_H


