
// This file is generated by src/Tools/generateTemaplates/templateClassPyExport.py out of the .XML file
// Every change you make here get lost at the next full rebuild!
#include "PreCompiled.h"

#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <Base/PyCXX/Objects.hxx>

#include "BaseClass.h"
#include "BaseClassPy.h"
#define new DEBUG_CLIENTBLOCK

using Base::streq;
using namespace Base;

/// Type structure of BaseClassPy
PyTypeObject BaseClassPy::Type = {
	PyObject_HEAD_INIT(&PyType_Type)
	0,                                                /*ob_size*/
	"BaseClass",                             /*tp_name*/
	sizeof(BaseClassPy),                       /*tp_basicsize*/
	0,                                                /*tp_itemsize*/
	/* methods */
	PyDestructor,                                     /*tp_dealloc*/
	0,                                                /*tp_print*/
	__getattr,                                        /*tp_getattr*/
	__setattr,                                        /*tp_setattr*/
	0,                                                /*tp_compare*/
	__repr,                                           /*tp_repr*/
	0,                                                /*tp_as_number*/
	0,                                                /*tp_as_sequence*/
	0,                                                /*tp_as_mapping*/
	0,                                                /*tp_hash*/
	0,                                                /*tp_call */
	0,                                                /*tp_str  */
	0,                                                /*tp_getattro*/
	0,                                                /*tp_setattro*/
	/* --- Functions to access object as input/output buffer ---------*/
	0,                                                /* tp_as_buffer */
	/* --- Flags to define presence of optional/expanded features */
	Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_CLASS,        /*tp_flags */
	"About BaseClass",                       /*tp_doc */
	0,                                                /*tp_traverse */
	0,                                                /*tp_clear */
	0,                                                /*tp_richcompare */
	0,                                                /*tp_weaklistoffset */
	0,                                                /*tp_iter */
	0,                                                /*tp_iternext */
	Base::BaseClassPy::Methods,                     /*tp_methods */
	0,                                                /*tp_members */
	Base::BaseClassPy::GeterSeter,                     /*tp_getset */
	&Base::PyObjectBase::Type,                        /*tp_base */
	0,                                                /*tp_dict */
	0,                                                /*tp_descr_get */
	0,                                                /*tp_descr_set */
	0,                                                /*tp_dictoffset */
	0,                                                /*tp_init */
	0,                                                /*tp_alloc */
	0,                                                /*tp_new */
	0,                                                /*tp_free   Low-level free-memory routine */
	0,                                                /*tp_is_gc  For PyObject_IS_GC */
	0,                                                /*tp_bases */
	0,                                                /*tp_mro    method resolution order */
	0,                                                /*tp_cache */
	0,                                                /*tp_subclasses */
	0                                                 /*tp_weaklist */
};

/// Methods structure of BaseClassPy
PyMethodDef BaseClassPy::Methods[] = {
	{"isDerivedFrom",
	  (PyCFunction) staticCallback_isDerivedFrom,
		Py_NEWARGS,
		"Returns true if given type is a father"
	},
	{"getAllDerivedFrom",
	  (PyCFunction) staticCallback_getAllDerivedFrom,
		Py_NEWARGS,
		"Returns all descentences"
	},
	{NULL, NULL}		/* Sentinel */
};

/// Attribute structure of BaseClassPy
PyGetSetDef BaseClassPy::GeterSeter[] = {
	{"Type",
	  (getter) staticCallback_getType,
    (setter) staticCallback_setType, 
    "Is the type of the FreeCAD object with module domain",
		NULL
	},
	{"Module",
	  (getter) staticCallback_getModule,
    (setter) staticCallback_setModule, 
    "Module in which this class is defined",
		NULL
	},
	{NULL, NULL}		/* Sentinel */
};

// isDerivedFrom() callback and implementer
// PyObject*  BaseClassPy::isDerivedFrom(PyObject *args){};
// has to be implemented in BaseClassPyImp.cpp
PyObject * BaseClassPy::staticCallback_isDerivedFrom (PyObject *self, PyObject *args, PyObject *kwd)
{
	try { // catches all exeptions coming up from c++ and generate a python exeption
	  return ((BaseClassPy*)self)->isDerivedFrom(args);
	}
	catch(Base::Exception &e) // catch the FreeCAD exeptions
	{
		std::string str;
		str += "FreeCAD exception thrown (";
		str += e.what();
		str += ")";
		e.ReportException();
		Py_Error(PyExc_Exception,str.c_str());
	}
	catch(boost::filesystem::filesystem_error &e) // catch boost filesystem exeption
	{
		std::string str;
		str += "File system exeption thrown (";
		//str += e.who();
    //str += ", ";
		str += e.what();
		str += ")\n";
		Base::Console().Error(str.c_str());
		Py_Error(PyExc_Exception,str.c_str());
	}
// in debug not all exceptions will be catcht to get the attentation of the developer!
#ifndef DONT_CATCH_CXX_EXCEPTIONS 
	catch(std::exception &e) // catch other c++ exeptions
	{
		std::string str;
		str += "FC++ exception thrown (";
		str += e.what();
		str += ")";
		Base::Console().Error(str.c_str());
		Py_Error(PyExc_Exception,str.c_str());
	}
	catch(...)  // catch the rest!
	{
		Py_Error(PyExc_Exception,"Unknown C++ exception");
	}
#endif
}
// getAllDerivedFrom() callback and implementer
// PyObject*  BaseClassPy::getAllDerivedFrom(PyObject *args){};
// has to be implemented in BaseClassPyImp.cpp
PyObject * BaseClassPy::staticCallback_getAllDerivedFrom (PyObject *self, PyObject *args, PyObject *kwd)
{
	try { // catches all exeptions coming up from c++ and generate a python exeption
	  return ((BaseClassPy*)self)->getAllDerivedFrom(args);
	}
	catch(Base::Exception &e) // catch the FreeCAD exeptions
	{
		std::string str;
		str += "FreeCAD exception thrown (";
		str += e.what();
		str += ")";
		e.ReportException();
		Py_Error(PyExc_Exception,str.c_str());
	}
	catch(boost::filesystem::filesystem_error &e) // catch boost filesystem exeption
	{
		std::string str;
		str += "File system exeption thrown (";
		//str += e.who();
    //str += ", ";
		str += e.what();
		str += ")\n";
		Base::Console().Error(str.c_str());
		Py_Error(PyExc_Exception,str.c_str());
	}
// in debug not all exceptions will be catcht to get the attentation of the developer!
#ifndef DONT_CATCH_CXX_EXCEPTIONS 
	catch(std::exception &e) // catch other c++ exeptions
	{
		std::string str;
		str += "FC++ exception thrown (";
		str += e.what();
		str += ")";
		Base::Console().Error(str.c_str());
		Py_Error(PyExc_Exception,str.c_str());
	}
	catch(...)  // catch the rest!
	{
		Py_Error(PyExc_Exception,"Unknown C++ exception");
	}
#endif
}
// Type() callback and implementer
// PyObject*  BaseClassPy::Type(PyObject *args){};
// has to be implemented in BaseClassPyImp.cpp

PyObject * BaseClassPy::staticCallback_getType (PyObject *self, void *closure)
{
    try {
        return Py::new_reference_to(((BaseClassPy*)self)->getType());
    } catch (...) {
		    PyErr_SetString(PyExc_Exception, "Unknown exeption while stting Attribute!");
        return NULL;
    }
}
int BaseClassPy::staticCallback_setType (PyObject *self, PyObject *value, void *closure)
{
 		PyErr_SetString(PyExc_Exception, "Can not write a read only Attribute!");
    return -1;
}

// Module() callback and implementer
// PyObject*  BaseClassPy::Module(PyObject *args){};
// has to be implemented in BaseClassPyImp.cpp

PyObject * BaseClassPy::staticCallback_getModule (PyObject *self, void *closure)
{
    try {
        return Py::new_reference_to(((BaseClassPy*)self)->getModule());
    } catch (...) {
		    PyErr_SetString(PyExc_Exception, "Unknown exeption while stting Attribute!");
        return NULL;
    }
}
int BaseClassPy::staticCallback_setModule (PyObject *self, PyObject *value, void *closure)
{
 		PyErr_SetString(PyExc_Exception, "Can not write a read only Attribute!");
    return -1;
}



//--------------------------------------------------------------------------
// Parents structure
//--------------------------------------------------------------------------
PyParentObject BaseClassPy::Parents[] = { PARENTSBaseClassPy };

//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
BaseClassPy::BaseClassPy(BaseClass *pcBaseClass, PyTypeObject *T)
	: PyObjectBase(pcBaseClass, T)
{

}

PyObject *BaseClassPy::PyMake(PyObject *ignored, PyObject *args)	// Python wrapper
{
	// never create such objects with the constructor
	return 0;
}

//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
BaseClassPy::~BaseClassPy()						// Everything handled in parent
{
}

//--------------------------------------------------------------------------
// PersistancePy representation
//--------------------------------------------------------------------------
PyObject *BaseClassPy::_repr(void)
{
	std::stringstream a;
	a << "BaseClass";
//  for(std::map<std::string,int>::const_iterator It = _pcFeature->_PropertiesMap.begin();It!=_pcFeature->_PropertiesMap.end();It++)
//  {
//    a << It->first << "=" << _pcFeature->GetProperty(It->first.c_str()).GetAsString() << "; ";
//  }
	a << "" << std::endl;
	return Py_BuildValue("s", a.str().c_str());
}

//--------------------------------------------------------------------------
// PersistancePy Attributes
//--------------------------------------------------------------------------
PyObject *BaseClassPy::_getattr(char *attr)				// __getattr__ function: note only need to handle new state
{ 
	try {
		// getter methode for special Attributes (e.g. dynamic ones)
		PyObject *r = getCustomAttributes(attr);
		if(r) return r;
	}
#ifndef DONT_CATCH_CXX_EXCEPTIONS 
	catch(Base::Exception &e) // catch the FreeCAD exeptions
	{
		std::string str;
		str += "FreeCAD exception thrown (";
		str += e.what();
		str += ")";
		e.ReportException();
		Py_Error(PyExc_Exception,str.c_str());
	}
	catch(std::exception &e) // catch other c++ exeptions
	{
		std::string str;
		str += "FC++ exception thrown (";
		str += e.what();
		str += ")";
		Base::Console().Error(str.c_str());
		Py_Error(PyExc_Exception,str.c_str());
	}
	catch(...)  // catch the rest!
	{
		Py_Error(PyExc_Exception,"Unknown C++ exception");
	}
#else  // DONT_CATCH_CXX_EXCEPTIONS  
	catch(Base::Exception &e) // catch the FreeCAD exeptions
	{
		std::string str;
		str += "FreeCAD exception thrown (";
		str += e.what();
		str += ")";
		e.ReportException();
		Py_Error(PyExc_Exception,str.c_str());
	}
#endif  // DONT_CATCH_CXX_EXCEPTIONS

	_getattr_up(PyObjectBase);
} 

int BaseClassPy::_setattr(char *attr, PyObject *value) 	// __setattr__ function: note only need to handle new state
{ 
	try {
		// setter for  special Attributes (e.g. dynamic ones)
		int r = setCustomAttributes(attr, value);
		if(r==1) return 1;
	}
#ifndef DONT_CATCH_CXX_EXCEPTIONS 
	catch(Base::Exception &e) // catch the FreeCAD exeptions
	{
		std::string str;
		str += "FreeCAD exception thrown (";
		str += e.what();
		str += ")";
		e.ReportException();
		Py_Error(PyExc_Exception,str.c_str());
	}
	catch(std::exception &e) // catch other c++ exeptions
	{
		std::string str;
		str += "FC++ exception thrown (";
		str += e.what();
		str += ")";
		Base::Console().Error(str.c_str());
		Py_Error(PyExc_Exception,str.c_str());
	}
	catch(...)  // catch the rest!
	{
		Py_Error(PyExc_Exception,"Unknown C++ exception");
	}
#else  // DONT_CATCH_CXX_EXCEPTIONS  
	catch(Base::Exception &e) // catch the FreeCAD exeptions
	{
		std::string str;
		str += "FreeCAD exception thrown (";
		str += e.what();
		str += ")";
		e.ReportException();
		Py_Error(PyExc_Exception,str.c_str());
	}
#endif  // DONT_CATCH_CXX_EXCEPTIONS

	return PyObjectBase::_setattr(attr, value);
}

BaseClass *BaseClassPy::getBaseClassObject(void) const
{
	return dynamic_cast<BaseClass *>(_pcBaseClass);
}

#if 0
/* from here on the methods you have to implement, but NOT in this module. Implement in BaseClassPyImp.cpp! This prototypes 
    are just for convenience! */
		

PyObject*  BaseClassPy::isDerivedFrom(PyObject *args)
{

}
PyObject*  BaseClassPy::getAllDerivedFrom(PyObject *args)
{

}

Py::String BaseClassPy::getType(void) const
{
	return Py::String();
}

	// no seter methode,  Type is read only!

Py::Int BaseClassPy::getModule(void) const
{
	return Py::Int();
}

	// no seter methode,  Module is read only!

PyObject *BaseClassPy::getCustomAttributes(const char* attr) const
{
	return 0;
}

int BaseClassPy::setCustomAttributes(const char* attr, PyObject *obj)
{
	return 0; 
}

#endif

	

