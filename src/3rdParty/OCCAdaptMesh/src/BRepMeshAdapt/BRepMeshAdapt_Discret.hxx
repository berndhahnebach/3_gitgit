// File generated by CPPExt (Transient)
//
//
//                     Copyright (C) 1991 - 2000 by  
//                      Matra Datavision SA.  All rights reserved.
//  
//                     Copyright (C) 2001 - 2004 by
//                     Open CASCADE SA.  All rights reserved.
// 
// This file is part of the Open CASCADE Technology software.
//
// This software may be distributed and/or modified under the terms and
// conditions of the Open CASCADE Public License as defined by Open CASCADE SA
// and appearing in the file LICENSE included in the packaging of this file.
//  
// This software is distributed on an "AS IS" basis, without warranty of any
// kind, and Open CASCADE SA hereby disclaims all such warranties,
// including without limitation, any warranties of merchantability, fitness
// for a particular purpose or non-infringement. Please see the License for
// the specific terms and conditions governing rights and limitations under the
// License.

#ifndef _BRepMeshAdapt_Discret_HeaderFile
#define _BRepMeshAdapt_Discret_HeaderFile

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Handle_BRepMeshAdapt_Discret_HeaderFile
#include <Handle_BRepMeshAdapt_Discret.hxx>
#endif

#ifndef _MeshShape_DataMapOfIntegerXY_HeaderFile
#include <MeshShape_DataMapOfIntegerXY.hxx>
#endif
#ifndef _Standard_Real_HeaderFile
#include <Standard_Real.hxx>
#endif
#ifndef _Standard_Boolean_HeaderFile
#include <Standard_Boolean.hxx>
#endif
#ifndef _BRepMeshAdapt_DataMapOfVertexInteger_HeaderFile
#include <BRepMeshAdapt_DataMapOfVertexInteger.hxx>
#endif
#ifndef _MeshShape_DataMapOfShapeListOfTransient_HeaderFile
#include <MeshShape_DataMapOfShapeListOfTransient.hxx>
#endif
#ifndef _Standard_Integer_HeaderFile
#include <Standard_Integer.hxx>
#endif
#ifndef _BRepMeshAdapt_DataMapOfIntegerFace_HeaderFile
#include <BRepMeshAdapt_DataMapOfIntegerFace.hxx>
#endif
#ifndef _MeshShape_DataMapOfIntegerPnt_HeaderFile
#include <MeshShape_DataMapOfIntegerPnt.hxx>
#endif
#ifndef _Handle_BRepMeshAdapt_DataStructureOfDelaun_HeaderFile
#include <Handle_BRepMeshAdapt_DataStructureOfDelaun.hxx>
#endif
#ifndef _BRepMeshAdapt_ListOfVertex_HeaderFile
#include <BRepMeshAdapt_ListOfVertex.hxx>
#endif
#ifndef _TColStd_IndexedMapOfInteger_HeaderFile
#include <TColStd_IndexedMapOfInteger.hxx>
#endif
#ifndef _TColgp_SequenceOfPnt2d_HeaderFile
#include <TColgp_SequenceOfPnt2d.hxx>
#endif
#ifndef _MeshShape_MapOfCouple_HeaderFile
#include <MeshShape_MapOfCouple.hxx>
#endif
#ifndef _MMgt_TShared_HeaderFile
#include <MMgt_TShared.hxx>
#endif
#ifndef _Handle_BRepAdaptor_HSurface_HeaderFile
#include <Handle_BRepAdaptor_HSurface.hxx>
#endif
class BRepMeshAdapt_DataStructureOfDelaun;
class TopoDS_Shape;
class TopoDS_Face;
class TopoDS_Edge;
class BRepAdaptor_HSurface;
class BRepMeshAdapt_Delaun;
class BRepMeshAdapt_Array1OfVertexOfDelaun;
class BRepMeshAdapt_ListOfVertex;
class TColStd_ListOfInteger;
class MeshShape_SurfacePoint;
class MeshShape_ListOfSurfacePoint;
class gp_XY;
class TopoDS_Vertex;
class gp_Pnt2d;
class BRepMeshAdapt_Triangle;
class BRepMeshAdapt_Edge;
class BRepMeshAdapt_Vertex;
class gp_Pnt;
class TColStd_MapOfInteger;
class gp_Dir;


//! Algorithm  to mesh  a shape  with  respect of  the <br>
//!          frontier the deflection  and by option the  shared <br>
//!          components. <br>
class BRepMeshAdapt_Discret : public MMgt_TShared {

public:
 // Methods PUBLIC
 // 


Standard_EXPORT BRepMeshAdapt_Discret(const Standard_Real defle,const Standard_Real angl = 0.17,const Standard_Boolean withShare = Standard_True,const Standard_Boolean inshape = Standard_False,const Standard_Boolean relative = Standard_False,const Standard_Boolean shapetrigu = Standard_False);


Standard_EXPORT BRepMeshAdapt_Discret(const Standard_Real defle,const TopoDS_Shape& shape,const Standard_Real angl = 0.17,const Standard_Boolean withShare = Standard_True,const Standard_Boolean inshape = Standard_False,const Standard_Boolean relative = Standard_False,const Standard_Boolean shapetrigu = Standard_False);

//! if the  boolean    <relative>   is  True,    the <br>
//!          deflection used   for the polygonalisation   of <br>
//!          each edge will be <defle> * Size of Edge. <br>
//!          the deflection used for the faces will be the maximum <br>
//!          deflection of their edges. <br>
//! <br>
//!          if <shapetrigu> is True, the triangulation, if exists <br>
//!          with a correct deflection, can be used to re-triangulate <br>
//!          the shape. <br>
//! <br>
//!          if   <inshape>   is   True, the      calculated <br>
//!          triangulation will be stored in the shape. <br>
Standard_EXPORT BRepMeshAdapt_Discret(const Standard_Real defle,const TopoDS_Face& face,const Standard_Real angl = 0.17,const Standard_Boolean withShare = Standard_True,const Standard_Boolean inshape = Standard_False,const Standard_Boolean relative = Standard_False,const Standard_Boolean shapetrigu = Standard_False);


Standard_EXPORT   void Add(const TopoDS_Shape& shape) ;


Standard_EXPORT   void Add(const TopoDS_Face& face) ;


Standard_EXPORT   void Add(const TopoDS_Edge& edge) ;


Standard_EXPORT   Standard_Boolean Update(const TopoDS_Edge& Edge,const TopoDS_Face& Face,const Standard_Real defedge) ;


Standard_EXPORT   void InternalVertices(BRepMeshAdapt_Delaun& trigu,const Handle(BRepAdaptor_HSurface)& caro,BRepMeshAdapt_Array1OfVertexOfDelaun& front,BRepMeshAdapt_ListOfVertex& inter,const Standard_Real defedge) ;


Standard_EXPORT   Standard_Boolean Control(const Handle(BRepAdaptor_HSurface)& caro,const Standard_Real defface,BRepMeshAdapt_ListOfVertex& inter,TColStd_ListOfInteger& badTri,TColStd_ListOfInteger& nulTri,const Standard_Boolean isfirst) ;


Standard_EXPORT   void QuadCut(const Handle(BRepAdaptor_HSurface)& caro,const MeshShape_SurfacePoint& P1,const MeshShape_SurfacePoint& P2,const MeshShape_SurfacePoint& P3,const MeshShape_SurfacePoint& P4,MeshShape_ListOfSurfacePoint& pntsOnSurf,const Standard_Real defedge) ;


Standard_EXPORT   Standard_Integer Uindex(const MeshShape_SurfacePoint& P) const;


Standard_EXPORT   Standard_Integer Vindex(const MeshShape_SurfacePoint& P) const;


Standard_EXPORT   void Append(MeshShape_ListOfSurfacePoint& pntsOnSurf,const MeshShape_SurfacePoint& P) ;


Standard_EXPORT   gp_XY FindUV(const TopoDS_Vertex& V,const gp_Pnt2d& XY,const Standard_Integer ip) ;

//! Gives  the number  of  domains. For  each  domain <br>
//!          there is a different TopFace. <br>
Standard_EXPORT   Standard_Integer NbDomains() const;

//! Gives the TopFace of the domain <Index>. <br>
Standard_EXPORT  const TopoDS_Face& DomainFace(const Standard_Integer Index) const;

//! Gives the number of built triangles. <br>
Standard_EXPORT   Standard_Integer NbTriangles() const;

//! Gives the triangle of <Index>. <br>
Standard_EXPORT  const BRepMeshAdapt_Triangle& Triangle(const Standard_Integer Index) const;

//! Gives the number of built Edges <br>
Standard_EXPORT   Standard_Integer NbEdges() const;

//! Gives the edge of index <Index>. <br>
Standard_EXPORT  const BRepMeshAdapt_Edge& Edge(const Standard_Integer Index) const;

//! Gives the number of built Vertices. <br>
Standard_EXPORT   Standard_Integer NbVertices() const;

//! Gives the vertex of <Index>. <br>
Standard_EXPORT  const BRepMeshAdapt_Vertex& Vertex(const Standard_Integer Index) const;

//! Gives the location3d of the vertex of <Index>. <br>
Standard_EXPORT  const gp_Pnt& Pnt(const Standard_Integer Index) const;

//! Gives the list of indices of the vertices of the <br>
//!          domain <Index>. <br>
Standard_EXPORT   void VerticesOfDomain(const Standard_Integer Index,TColStd_MapOfInteger& Indices) const;

//! Gives the list of indices of the edges of the <br>
//!          domain <Index>. <br>
Standard_EXPORT   void EdgesOfDomain(const Standard_Integer Index,TColStd_MapOfInteger& Indices) const;

//! Gives the list of indices of the triangles <br>
//!          of the domain <Index>. <br>
Standard_EXPORT   void TrianglesOfDomain(const Standard_Integer Index,TColStd_MapOfInteger& Indices) const;

//! Gives the  number of different  location in 3d <br>
//!          space.  It  is  different    of the number  of <br>
//!          vertices if there is more than one surface. <br>
//!          Even for one surface, the number can be different <br>
//!          if an edge is shared. <br>
Standard_EXPORT   Standard_Integer NbPoint3d() const;

//! Gives the 3d space location of the vertex <Index>. <br>
Standard_EXPORT  const gp_Pnt& Point3d(const Standard_Integer Index) const;

//! Gives the normale of   the vertex of <Index>  on <br>
//!          his face. <br>
//! <br>
//!          This  function create  at each call the surface. <br>
//!          To optimize the systematic computing you can use <br>
//!          the folowing loop : <br>
//! <br>
//!          Surface mySurface(DomainFace(theDomain)); <br>
//!          loop-On-Vertices-Of-theDomain { <br>
//!            GeomTool::Normal(mySurface, u, v, Pnt, Dir); <br>
//!          } <br>
//! <br>
//!          WARNING : The vertex from wich the <u> and <v> are <br>
//!          used is on <theDomain>. <br>
//! <br>
Standard_EXPORT   void Normal(const Standard_Integer Index,gp_Pnt& Pon,gp_Dir& Nor) const;

//! Gives the data structure of the mesh. <br>
Standard_EXPORT   Handle_BRepMeshAdapt_DataStructureOfDelaun Result() const;

//! returns the deflection value. <br>
Standard_EXPORT   Standard_Real GetDeflection() const;

//! returns the deflection value. <br>
Standard_EXPORT   Standard_Real GetAngle() const;
//Standard_EXPORT ~BRepMeshAdapt_Discret();




 // Type management
 //
 Standard_EXPORT const Handle(Standard_Type)& DynamicType() const;
 //Standard_EXPORT Standard_Boolean	       IsKind(const Handle(Standard_Type)&) const;

protected:

 // Methods PROTECTED
 // 


 // Fields PROTECTED
 //


private: 

 // Methods PRIVATE
 // 


Standard_EXPORT   void Add(const TopoDS_Edge& edge,const TopoDS_Face& face,const Handle(BRepAdaptor_HSurface)& S,const Standard_Real defedge) ;


Standard_EXPORT   void AddInShape(const TopoDS_Face& face,const Standard_Real defedge) ;


 // Fields PRIVATE
 //
MeshShape_DataMapOfIntegerXY myrealuv;
Standard_Real angle;
Standard_Real deflection;
Standard_Boolean WithShare;
BRepMeshAdapt_DataMapOfVertexInteger vertices;
MeshShape_DataMapOfShapeListOfTransient edges;
MeshShape_DataMapOfShapeListOfTransient internaledges;
Standard_Integer nbDomains;
BRepMeshAdapt_DataMapOfIntegerFace Domains;
Standard_Integer nbLocat;
MeshShape_DataMapOfIntegerPnt Location3d;
Handle_BRepMeshAdapt_DataStructureOfDelaun structure;
BRepMeshAdapt_ListOfVertex mylistver;
TColStd_IndexedMapOfInteger myvemap;
MeshShape_DataMapOfIntegerXY mylocation2d;
TColgp_SequenceOfPnt2d myVeloc;
MeshShape_MapOfCouple mymap;
Standard_Real myumin;
Standard_Real myumax;
Standard_Real myvmin;
Standard_Real myvmax;
Standard_Boolean myrelative;
Standard_Boolean myshapetrigu;
Standard_Boolean myinshape;


};





// other Inline functions and methods (like "C++: function call" methods)
//


#endif
