// File:	MeshAlgoAdapt_Delaunay.gxx
// Created:	Wed May 12 08:58:20 1993
// Author:	Didier PIFFAULT
//		<dpf@zerox>

#include <Standard_DomainError.hxx>
#include <gp_XY.hxx>
#include <gp_Pnt2d.hxx>
#include <gp_Vec2d.hxx>
#include <TColStd_ListIteratorOfListOfInteger.hxx>
#include <TColStd_ListOfInteger.hxx>
#include <TColStd_MapIteratorOfMapOfInteger.hxx>
#include <TColStd_DataMapIteratorOfDataMapOfIntegerInteger.hxx>
#include <Precision.hxx>
#include <Bnd_Box2d.hxx>
#include <gp.hxx>

typedef TColStd_ListIteratorOfListOfInteger  IteratorOnListOfInteger;
typedef TColStd_ListOfInteger                ListOfInteger;

const gp_XY SortingDirection(M_SQRT1_2, M_SQRT1_2);

//#define TRIANGULATION_MESURE

#ifdef TRIANGULATION_MESURE
#include <OSD_Chronometer.hxx>
static OSD_Chronometer ChroTrigu;
static OSD_Chronometer ChroSearch;
static OSD_Chronometer ChroDelete;
static OSD_Chronometer ChroDelTri;
static OSD_Chronometer ChroDelCir;
static OSD_Chronometer ChroCreate;
static OSD_Chronometer ChroFront;
Standard_EXPORT Standard_Boolean Triangulation_Chrono;
#endif

//#define TRIANGULATION_DEBUG

#ifdef TRIANGULATION_DEBUG
Standard_IMPORT Standard_Integer Triangulation_Trace;
#endif


//=======================================================================
//function : MeshAlgoAdapt_Delaunay
//purpose  : 
//=======================================================================
MeshAlgoAdapt_Delaunay::MeshAlgoAdapt_Delaunay
  (MeshAlgoAdapt_Array1OfVertex& Vertices, const Standard_Boolean ZPositive)
:  PositiveOrientation(ZPositive), tCircles(Vertices.Length())
{
  if (Vertices.Length()>2) {
    theDomain=Vertices(Vertices.Lower()).Domain();
    MeshData=new MeshAlgoAdapt_DataStructure(Vertices.Length());
    MeshData->NewDomain(theDomain);
    Init(Vertices);
  }
}

//=======================================================================
//function : MeshAlgoAdapt_Delaunay
//purpose  : 
//=======================================================================
MeshAlgoAdapt_Delaunay::MeshAlgoAdapt_Delaunay 
  (const Handle(MeshAlgoAdapt_DataStructure)& OldMesh, 
   MeshAlgoAdapt_Array1OfVertex& Vertices,
   const Standard_Boolean ZPositive)
:  PositiveOrientation(ZPositive), tCircles(Vertices.Length())
{
  MeshData=OldMesh;
  if (Vertices.Length()>2) {
    theDomain=Vertices(Vertices.Lower()).Domain();
    MeshData->NewDomain(theDomain);
    Init(Vertices);
  }
}


//=======================================================================
//function : Init
//purpose  : 
//=======================================================================
void MeshAlgoAdapt_Delaunay::Init(MeshAlgoAdapt_Array1OfVertex& Vertices)
{
  Bnd_Box2d theBox;
  TColStd_Array1OfInteger vertexIndices(Vertices.Lower(), Vertices.Upper());
  Standard_Integer niver;

  for (niver=Vertices.Lower(); niver<=Vertices.Upper(); niver++) {
    theBox.Add(gp_Pnt2d(Vertices(niver).Coord()));
    vertexIndices(niver)=MeshData->AddNode(Vertices(niver));
  }

  theBox.Enlarge(Precision::PConfusion());
  SuperMesh(theBox);

  MeshAlgoAdapt_HeapSortIndexedVertex::Sort
    (vertexIndices, 
     MeshAlgoAdapt_ComparatorOfIndexedVertex(SortingDirection,
					Precision::PConfusion(),
					MeshData));

  Compute(vertexIndices);
}


//=======================================================================
//function : MeshAlgoAdapt_Delaunay
//purpose  : 
//=======================================================================
MeshAlgoAdapt_Delaunay::MeshAlgoAdapt_Delaunay 
  (const Handle(MeshAlgoAdapt_DataStructure)& OldMesh, 
   TColStd_Array1OfInteger& VertexIndices,
   const Standard_Boolean ZPositive)
:  PositiveOrientation(ZPositive), tCircles(VertexIndices.Length())
{
  MeshData=OldMesh;
  if (VertexIndices.Length()>2) {
    theDomain=GetVertex(VertexIndices.Lower()).Domain();
    MeshData->NewDomain(theDomain);

    Bnd_Box2d theBox;
    Standard_Integer niver;
    for (niver=VertexIndices.Lower(); niver<=VertexIndices.Upper(); niver++) {
      theBox.Add(gp_Pnt2d(GetVertex(VertexIndices(niver)).Coord()));
    }

    theBox.Enlarge(Precision::PConfusion());
    SuperMesh(theBox);

    MeshAlgoAdapt_HeapSortIndexedVertex::Sort
      (VertexIndices, 
       MeshAlgoAdapt_ComparatorOfIndexedVertex(SortingDirection,
					  Precision::PConfusion(),
					  MeshData));

    Compute(VertexIndices);
  }
}

//=======================================================================
//function : Compute
//purpose  : 
//=======================================================================
void MeshAlgoAdapt_Delaunay::Compute (TColStd_Array1OfInteger& VertexIndices)
{
// Insertion des arêtes du super triangles dans la liste des arêtes libres :
  TColStd_DataMapOfIntegerInteger loopEdges;
  Standard_Integer e1, e2, e3;
  Standard_Boolean o1, o2, o3;
  supTrian.Edges(e1, e2, e3, o1, o2, o3);
  loopEdges.Bind(e1, Standard_True);
  loopEdges.Bind(e2, Standard_True);
  loopEdges.Bind(e3, Standard_True);
  
  if (VertexIndices.Length()>0) {

// Création des 3 triangles avec le node et les edges du super triangle :
    Standard_Integer iVert=VertexIndices.Lower();
    CreateTriangles(GetVertex(VertexIndices(iVert)), loopEdges);

// Insertion des noeuds :
    Standard_Boolean modif=Standard_True;
    Standard_Integer edgeOn, triPerce;
    IteratorOnListOfInteger itT;
    
    for (iVert++; iVert<=VertexIndices.Upper(); iVert++) {
      const Vertex& refToVert=GetVertex(VertexIndices(iVert));
      loopEdges.Clear();

    // Liste des indices des cercles contenant le noeud :

      ListOfInteger& cirL=tCircles.Select(refToVert.Coord());

      edgeOn=0;
      triPerce=0;

      for (itT.Initialize(cirL); itT.More(); itT.Next()) {
      // Pour ajouter un noeud au maillage il faut verifier deux conditions :
      // - le noeud doit etre dans les frontieres du maillage et donc
      //   dans un triangle existant
      // - tous les triangles touches doivent faire partie d une composante
      //   connexe de ce triangle
	if (Contains(itT.Value(), refToVert, edgeOn)) {
	  triPerce=itT.Value();
	  cirL.Remove(itT);
	  break;
	}
      }

      if (triPerce>0) {
	DeleteTriangle(triPerce, loopEdges);

	modif=Standard_True;
	while (modif && !cirL.IsEmpty()) {
	  modif=Standard_False;
	  for (itT.Initialize(cirL); itT.More(); itT.Next()) {
	    GetTriangle(itT.Value()).Edges(e1,e2,e3,o1,o2,o3);
	    if (loopEdges.IsBound(e1) || 
		loopEdges.IsBound(e2) || 
		loopEdges.IsBound(e3)) {
	      modif=Standard_True;
	      DeleteTriangle(itT.Value(), loopEdges);
	      cirL.Remove(itT);
	      break;
	    }
	  }
	}

    // Création des triangles avec le node courant et les edges libres
    // et suppression de ces edges de la liste des edges libres :

#ifdef TRIANGULATION_DEBUG
	if (Triangulation_Trace>0) {
	  cout << " creation triangle avec le vertex: ";
	  cout << refToVert.Coord().X() << "  " << refToVert.Coord().Y() << endl;
	}
#endif
	CreateTriangles(refToVert, loopEdges);

      }
    }

 //  Destruction des triangles contenant un sommet du super triangle :

    MeshAlgoAdapt_SelectorOfDataStructure select(MeshData);
    select.NeighboursOfNode(supVert1);
    select.NeighboursOfNode(supVert2);
    select.NeighboursOfNode(supVert3);
    TColStd_MapIteratorOfMapOfInteger trs(select.Elements());
    loopEdges.Clear();
    for (;trs.More(); trs.Next()) {
      DeleteTriangle(trs.Key(), loopEdges);
    }

  // On enleve de loopEdges toutes les edges restées libres ; il ne reste
  // donc dans loopEdges  que les edges frontière de  la triangulation.

    TColStd_DataMapIteratorOfDataMapOfIntegerInteger itLEd(loopEdges);
    for (; itLEd.More(); itLEd.Next()) {
      if (MeshData->ElemConnectedTo(itLEd.Key()).IsEmpty())
	MeshData->RemoveLink(itLEd.Key());
    }

  // On détruit les sommets du super triangle:

    MeshData->RemoveNode(supVert1);
    MeshData->RemoveNode(supVert2);
    MeshData->RemoveNode(supVert3);



  // Verification que les aretes internes ne sont pas traversees par des triangles.
    TColStd_MapIteratorOfMapOfInteger itFr(InternalEdges(theDomain));

//  Destruction des triangles intersectant les arêtes internes et 
//  remplacement par des triangles ad-Hoc :

    Standard_Integer nbc;
    //IteratorOnListOfInteger itconx;
    itFr.Reset();
    for (; itFr.More(); itFr.Next()) {
      nbc = MeshData->ElemConnectedTo(itFr.Key()).Extent();
      if (nbc == 0) {
	MeshLeftPolygonOf(itFr.Key(), Standard_True); 
	MeshLeftPolygonOf(itFr.Key(), Standard_False); 
      }
    }
  
  // Ajustement des mailles aux aretes frontieres :
    FrontierAdjust();

 // Validation du circle tool. 
    tCircles.Valid();

  }
}

//=======================================================================
//function : ReCompute
//purpose  : 
//=======================================================================
void MeshAlgoAdapt_Delaunay::ReCompute (TColStd_Array1OfInteger& VertexIndices)
{
  MeshData->ClearDomain(theDomain);

// Initialisation du CircleTool :
  tCircles.Initialize(VertexIndices.Length());

  if (VertexIndices.Length()>2) {
    MeshData->NewDomain(theDomain);
    Compute(VertexIndices);
  }
}


//=======================================================================
//function : FrontierAdjust
//purpose  : 
//=======================================================================
void MeshAlgoAdapt_Delaunay::FrontierAdjust()
{
// Recherche des triangles extérieurs aux arêtes Frontieres:

  Standard_Integer e1, e2, e3;
  Standard_Boolean o1, o2, o3;
  TColStd_DataMapOfIntegerInteger loopEdges;
  TColStd_MapIteratorOfMapOfInteger itFr(Frontier(theDomain));
  IteratorOnListOfInteger itconx;
  ListOfInteger tril;


  for (; itFr.More(); itFr.Next()) {
    const ListOfInteger& conx=MeshData->ElemConnectedTo(itFr.Key());
    if (conx.Extent()>0) {
      for (itconx.Initialize(conx); itconx.More(); itconx.Next()) {
	const Triangle& trc=GetTriangle(itconx.Value());
	trc.Edges(e1,e2,e3,o1,o2,o3);
	if      ((itFr.Key()==e1 && !o1) || 
		 (itFr.Key()==e2 && !o2) ||
		 (itFr.Key()==e3 && !o3))   {
#ifdef TRIANGULATION_DEBUG
	if (Triangulation_Trace>0) {
	  cout << "---> destruction du triangle " << itconx.Value() << endl;
	}
#endif
	  tril.Append(itconx.Value());
	}
      }
    }
  }

//  Destruction des triangles extérieurs aux arêtes Frontieres:

  for (; !tril.IsEmpty(); tril.RemoveFirst()) {
    DeleteTriangle(tril.First(), loopEdges);
  }

//  Destruction des arêtes restées pendantes :

  TColStd_DataMapIteratorOfDataMapOfIntegerInteger itFE(loopEdges);

  for (; itFE.More(); itFE.Next()) {
    if (MeshData->ElemConnectedTo(itFE.Key()).IsEmpty())
      MeshData->RemoveLink(itFE.Key());
  }


//  Destruction des triangles interferant les arêtes Frontieres et 
//  remplacement par des triangles ad-Hoc :

  itFr.Reset();
  for (; itFr.More(); itFr.Next()) {
    if (MeshData->ElemConnectedTo(itFr.Key()).IsEmpty()) { 
      MeshLeftPolygonOf(itFr.Key(), Standard_True); 
    }
  }

// Après ces traitements il reste parfois des triangles à l''extérieur des
// frontières. Destruction de ces triangles :

  Standard_Integer nbFront;

  // Pour chaque arête n'ayant qu'une connéxité :
  // Si par un de ses sommets il passe déjà deux arêtes frontière
  // le triangle connexes est a l''extérieur du contour :
  
  Standard_Boolean again = Standard_True;

  while (again) {
    tril.Clear();
    loopEdges.Clear();

    for (itFr.Initialize(FreeEdges(theDomain)); itFr.More(); itFr.Next()) {
      const Edge& edg=GetEdge(itFr.Key());
      if (edg.Movability()!=MeshDS_Frontier) {
	nbFront=0;
	if (MeshData->ElemConnectedTo(itFr.Key()).IsEmpty()) 
	  loopEdges.Bind(itFr.Key(), Standard_True);
	else {
	  for (itconx.Initialize(MeshData->LinkNeighboursOf(edg.FirstNode()));
	       itconx.More(); itconx.Next()) {
	    if (GetEdge(itconx.Value()).Movability()==MeshDS_Frontier) {
	      nbFront++;
	      if (nbFront>1) break;
	    }
	  }
	  if (nbFront==2) {
	    for (itconx.Initialize(MeshData->ElemConnectedTo(itFr.Key())); 
		 itconx.More(); itconx.Next()) {
	      GetTriangle(itconx.Value()).Edges(e1, e2, e3, o1, o2, o3);
	      if (GetEdge(e1).Movability()==MeshDS_Free &&
		  GetEdge(e2).Movability()==MeshDS_Free &&
		  GetEdge(e3).Movability()==MeshDS_Free) {
#ifdef TRIANGULATION_DEBUG
	if (Triangulation_Trace>0) {
		cout << " ----> destruction du triangle" << itconx.Value() <<endl;
	      }
#endif
		tril.Append(itconx.Value());
	      }
	    }
	  }
	}
      }
    }
    
    // Destruction des triangles :
    Standard_Integer kk = 0;
    for (; !tril.IsEmpty(); tril.RemoveFirst()) {
      DeleteTriangle(tril.First(), loopEdges);
      kk++;
    }

    //  Destruction des arêtes restées pendantes :
    
    for (itFE.Initialize(loopEdges); itFE.More(); itFE.Next()) {
      if (MeshData->ElemConnectedTo(itFE.Key()).IsEmpty())
	MeshData->RemoveLink(itFE.Key());
    }

    if (kk == 0) break;
  }



//  Dans certains cas il reste des frontieres non utilisees Verification :
 
  for (itFr.Initialize(Frontier(theDomain)); itFr.More(); itFr.Next()) {
    if (MeshData->ElemConnectedTo(itFr.Key()).IsEmpty()) { 
      MeshLeftPolygonOf(itFr.Key(), Standard_True); 
    }
  }
}




//=======================================================================
//function : MeshLeftPolygonOf
//purpose  : Triangulation du polygon à gauche de <indexEdg>.(coté matière)
//=======================================================================
void MeshAlgoAdapt_Delaunay::MeshLeftPolygonOf(const Standard_Integer indexEdg,
					  const Standard_Boolean forwdEdg)
{
  const Edge& edg=GetEdge(indexEdg);
  TColStd_SequenceOfInteger polyg;
  TColStd_DataMapOfIntegerInteger loopEdges;
  TColStd_MapOfInteger usedEdges;

// Recherche du polygon :
  
  usedEdges.Add(indexEdg);
  Standard_Integer debut, prem, pivo;
#ifndef DEB
  Standard_Integer ders =0, oth =0;
#else
  Standard_Integer ders, oth;
#endif
  if (forwdEdg) {
    polyg.Append(indexEdg);
    prem=edg.FirstNode();
    pivo=edg.LastNode();
  }
  else {
    polyg.Append(-indexEdg);
    prem=edg.LastNode();
    pivo=edg.FirstNode();
  }
  debut=prem;
  const Vertex& debEd=GetVertex(debut);
  const Vertex& finEd=GetVertex(pivo);

// Vérification de la présence d''une arête précèdant <indexEdg> :
  IteratorOnListOfInteger itLiVer(MeshData->LinkNeighboursOf(prem));
  for (; itLiVer.More(); itLiVer.Next()) {
    oth=0;
    if (itLiVer.Value()!=indexEdg) {
      const Edge& nedg=GetEdge(itLiVer.Value());
      oth=nedg.LastNode();
      if (oth==prem) oth=nedg.FirstNode();
      break;
    }
  }
  if (oth==0) {
#ifdef TRIANGULATION_DEBUG
    if (Triangulation_Trace>0)
      cout << " MeshLeftPolygonOf : Aucun chemin Edge précédente !" << endl; 
#endif
    return;
  }

 
  gp_XY vedge(finEd.Coord());
  vedge.Subtract(debEd.Coord());
  gp_XY ved1(vedge);
  gp_XY ved2;
  Standard_Integer curEdg=indexEdg, e1, e2, e3;
  Standard_Boolean o1, o2, o3;

// Recherche du polygone fermé au plus près de <indexEdg> :
  Standard_Boolean InMesh, notInters;
  Standard_Integer nextedge;
  Standard_Real ang, angref;
  gp_XY vpivo, vedcur, voth;

  while (pivo!=debut) {
    nextedge=0;
    if (PositiveOrientation) angref=RealFirst();
    else                     angref=RealLast();
    const Vertex& vertPivo=GetVertex(pivo);
    vpivo=vertPivo.Coord();
    vpivo.Subtract(debEd.Coord());

    itLiVer.Initialize(MeshData->LinkNeighboursOf(pivo));

    // Recherche de l'arête suivante formant le plus grand angle avec
    // <indexEdg> et n'intersectant pas <indexEdg> :

    for (; itLiVer.More(); itLiVer.Next()) {
      if (itLiVer.Value()!=curEdg) {
	notInters=Standard_True;
	const Edge& nedg=GetEdge(itLiVer.Value());

	InMesh=Standard_True;
	if (nedg.Movability()==MeshDS_Free) {
	  if (MeshData->ElemConnectedTo(itLiVer.Value()).IsEmpty()) 
	    InMesh=Standard_False;
	}

	if (InMesh) {
	  oth=nedg.FirstNode();
	  if (oth==pivo) oth=nedg.LastNode();

	  vedcur=GetVertex(oth).Coord();
	  vedcur.Subtract(vertPivo.Coord());
	  if (vedcur.Modulus() >= gp::Resolution() &&
	      ved1.Modulus() >= gp::Resolution()) {
	    if (prem!=debut && oth!=debut) {
	      voth=GetVertex(oth).Coord();
	      voth.Subtract(debEd.Coord());
	      if ((vedge^vpivo)*(vedge^voth)<0.) {
		voth=vertPivo.Coord();
		voth.Subtract(finEd.Coord());
		if ((vedcur^vpivo)*(vedcur^voth)<0.) 
		  notInters=Standard_False;
	      }
	    }
	    
	    if (notInters) {
	      ang=gp_Vec2d(ved1).Angle(gp_Vec2d(vedcur));
	      
	      if ((PositiveOrientation && ang>angref) ||
		  (!PositiveOrientation && ang<angref)) {
		angref=ang;
		ved2=vedcur;
		if (nedg.FirstNode()==pivo) nextedge=itLiVer.Value();
		else                        nextedge=-itLiVer.Value();
		ders=oth;
		if (ders==debut) break;
	      }
	    }
	  }
	}
      }
    }

    if (nextedge!=0) {
      if (Abs(nextedge)!=indexEdg && Abs(nextedge)!=curEdg) {
	curEdg=Abs(nextedge);

	if (!usedEdges.Add(curEdg)) {
	  // Si on a déjà ajouter cette edge au polygone il ya risque
	  // de bouclage (attention aux contours ouverts)

#ifdef TRIANGULATION_DEBUG
	  if (Triangulation_Trace>0)
	    cout << " MeshLeftPolygonOf : pas de fermeture du polygone !" 
	      << endl; 
#endif

	  // On enlève du polygon toutes les edges du contour frontière :

	  curEdg=Abs(polyg(polyg.Length()));
	  while (GetEdge(curEdg).Movability()==MeshDS_Frontier){
	    polyg.Remove(polyg.Length());
	    if (polyg.Length()<=0) break;
	    curEdg=Abs(polyg(polyg.Length()));
	  }
	  return;
	}

	polyg.Append(nextedge);

	Standard_Boolean forw=nextedge>0;

	IteratorOnListOfInteger itCx(MeshData->ElemConnectedTo(curEdg));
	for (; itCx.More(); itCx.Next()) {
	  GetTriangle(itCx.Value()).Edges(e1,e2,e3,o1,o2,o3);
	  if ((e1==curEdg && o1==forw) || 
	      (e2==curEdg && o2==forw) ||
	      (e3==curEdg && o3==forw)) {
	    DeleteTriangle(itCx.Value(), loopEdges);
	    break;
	  }
	}
      }
    }
    else {
#ifdef TRIANGULATION_DEBUG
      if (Triangulation_Trace>0)
	cout << " MeshLeftPolygonOf : Pas de suivante !" << endl; 
#endif
      return;
    }
    prem=pivo;
    pivo=ders;
    ved1=ved2;
  }


// Destruction des arêtes libres inutiles :

  TColStd_DataMapIteratorOfDataMapOfIntegerInteger itFE(loopEdges);

  for (; itFE.More(); itFE.Next()) {
    if (MeshData->ElemConnectedTo(itFE.Key()).IsEmpty())
      MeshData->RemoveLink(itFE.Key());
  }

  MeshPolygon(polyg);
}


//=======================================================================
//function : MeshPolygon
//purpose  : Triangule un polygon fermé décrit par la liste des index de
//           ses arêtes dans la structure. (index négatif == reversed)
//=======================================================================
void MeshAlgoAdapt_Delaunay::MeshPolygon  (TColStd_SequenceOfInteger& poly)
{
  Standard_Integer vert, vert1, vert2, vert3 =0, tri;

  if (poly.Length()==3) {
    tri=MeshData->AddElement(Triangle(Abs(poly(1)),Abs(poly(2)),Abs(poly(3)), 
				      poly(1)>0,   poly(2)>0,   poly(3)>0,
				      MeshDS_Free, theDomain));
    const Edge& edg1=GetEdge(Abs(poly(1)));
    const Edge& edg2=GetEdge(Abs(poly(2)));
    if (poly(1)>0) {
      vert1=edg1.FirstNode();
      vert2=edg1.LastNode();
    }
    else {
      vert1=edg1.LastNode();
      vert2=edg1.FirstNode();
    }
    if (poly(2)>0) 
      vert3=edg2.LastNode();
    else
      vert3=edg2.FirstNode();

    if (!tCircles.Add(GetVertex(vert1).Coord(), 
		      GetVertex(vert2).Coord(), 
		      GetVertex(vert3).Coord(),
		      tri)) {
      MeshData->RemoveElement(tri);
    }
  }

  else if (poly.Length()>3) {
    const Edge& edg=GetEdge(Abs(poly(1)));
    Standard_Real distmin=RealLast();
    Standard_Integer ip, used =0;

    if (poly(1)>0) {
      vert1=edg.FirstNode();
      vert2=edg.LastNode();
    }
    else {
      vert1=edg.LastNode();
      vert2=edg.FirstNode();
    }
    gp_XY vedg(GetVertex(vert2).Coord()-
               GetVertex(vert1).Coord());
    Standard_Real modul=vedg.Modulus();
    if (modul>0.) {
      vedg.SetCoord(vedg.X()/modul, vedg.Y()/modul);

      for (ip=3; ip<=poly.Length(); ip++) {
	const Edge& nedg=GetEdge(Abs(poly(ip)));
	if (poly(ip)>0) vert=nedg.FirstNode();
	else            vert=nedg.LastNode();
	gp_XY vep(GetVertex(vert).Coord()-GetVertex(vert2).Coord());
	
	Standard_Real dist=vedg^vep;
	if (Abs(dist)>Precision::PConfusion()) {
	  if ((dist>0. && PositiveOrientation) || 
	      (dist<0. && !PositiveOrientation)) { 
	    if (Abs(dist)<distmin) {
	      distmin=dist;
	      vert3=vert;
	      used=ip;
	    }
	  }
	}
      }
    }

    Standard_Integer ne2, ne3;
    if (distmin<RealLast()) {
      ne2=MeshData->AddLink(Edge(vert2, vert3, MeshDS_Free, theDomain));
      ne3=MeshData->AddLink(Edge(vert3, vert1, MeshDS_Free, theDomain));
      tri=MeshData->AddElement(Triangle(Abs(poly(1)), Abs(ne2), Abs(ne3), 
					(poly(1)>0),  (ne2>0),  (ne3>0),
					MeshDS_Free, theDomain));

      if (!tCircles.Add(GetVertex(vert1).Coord(), 
			GetVertex(vert2).Coord(), 
			GetVertex(vert3).Coord(),
			tri)) {
	MeshData->RemoveElement(tri);
      }

      if (used<poly.Length()) {
	TColStd_SequenceOfInteger suitePoly;
	poly.Split(used, suitePoly);
	suitePoly.Prepend(-ne3);
	MeshPolygon(suitePoly);
      }
      else 
	poly.Remove(poly.Length());

      if (used>3) {
	poly.SetValue(1, -ne2);
	MeshPolygon(poly);
      }
    }
    else {
#ifdef TRIANGULATION_DEBUG
      if (Triangulation_Trace>0) {
	cout << " MeshPolygon : aucune possibilité !" << endl;
	if (Triangulation_Trace==5) {
	  cout << " MeshPolygon : ";
	  for (vert=1; vert<=poly.Length(); vert++) 
	    cout << poly(vert) << " ";
	  cout<<endl;
	}
      }
#endif
    }
  }
}

//=======================================================================
//function : SuperMesh
//purpose  : 
//=======================================================================
void MeshAlgoAdapt_Delaunay::SuperMesh  (const Bnd_Box2d& theBox)
{
  Standard_Real xMin, yMin, xMax, yMax;
  theBox.Get(xMin, yMin, xMax, yMax);
  Standard_Real deltax=xMax-xMin;
  Standard_Real deltay=yMax-yMin;

  Standard_Real deltaMin=Min(deltax, deltay);
  Standard_Real deltaMax=Max(deltax, deltay);
  Standard_Real delta=deltax+deltay;

  supVert1=MeshData->AddNode(Vertex((xMin+xMax)/2, yMax+deltaMax,
				    theDomain, MeshDS_Free));
  supVert2=MeshData->AddNode(Vertex(xMin-delta, yMin-deltaMin, 
				    theDomain, MeshDS_Free));
  supVert3=MeshData->AddNode(Vertex(xMax+delta, yMin-deltaMin,
				    theDomain, MeshDS_Free));

  Standard_Integer niver;
  if (!PositiveOrientation) {
    niver=supVert2;
    supVert2=supVert3;
    supVert3=niver;
  }

  Standard_Integer 
    ed1=MeshData->AddLink(Edge(supVert1,supVert2,MeshDS_Free, theDomain));
  Standard_Integer 
    ed2=MeshData->AddLink(Edge(supVert2,supVert3,MeshDS_Free, theDomain));
  Standard_Integer 
    ed3=MeshData->AddLink(Edge(supVert3,supVert1,MeshDS_Free, theDomain));
  supTrian=Triangle(Abs(ed1), Abs(ed2), Abs(ed3), 
		    (ed1>0), (ed2>0), (ed3>0), MeshDS_Free, theDomain);
}


//=======================================================================
//function : CreateTriangles
//purpose  : Création des triangles avec le node courant et les edges
//           libres et suppression de ces edges de la liste :
//=======================================================================
void MeshAlgoAdapt_Delaunay::CreateTriangles 
  (const Vertex& theVertex,  TColStd_DataMapOfIntegerInteger& theEdges)
{
  TColStd_DataMapIteratorOfDataMapOfIntegerInteger itFE(theEdges);
  Standard_Real z12, z23, modul;
  Standard_Integer ne1, ne3, nt;
  Standard_Integer nv=MeshData->IndexOf(theVertex);
  gp_XY vl1, vl2, vl3;
  ListOfInteger EdgLoop, EdgOK, EdgExter;

  for (; itFE.More(); itFE.Next()) {
    const Edge& edg=GetEdge(itFE.Key());
    Standard_Integer deb=edg.FirstNode();
    Standard_Integer fin=edg.LastNode();
    Standard_Boolean sens=(Standard_Boolean)theEdges(itFE.Key());
    if (!sens) {
      nt=deb;
      deb=fin;
      fin=nt;
    }

    const Vertex& debVert=GetVertex(deb);
    const Vertex& finVert=GetVertex(fin);

    vl1=debVert.Coord();
    vl1.Subtract(theVertex.Coord());
    vl2=finVert.Coord();
    vl2.Subtract(debVert.Coord());
    vl3=theVertex.Coord();
    vl3.Subtract(finVert.Coord());

    z12=z23=0.;
    modul=vl2.Modulus();
    if (modul>Precision::PConfusion()) {
      vl2.SetCoord(vl2.X()/modul, vl2.Y()/modul);
      z12=vl1^vl2;
      z23=vl2^vl3;
    }

    if (Abs(z12)>=Precision::PConfusion() && 
	Abs(z23)>=Precision::PConfusion()) {
      Standard_Boolean sensOK;
      if (PositiveOrientation) sensOK=(z12>0. && z23>0.);
      else                     sensOK=(z12<0. && z23<0.);
      if (sensOK) {
	ne1=MeshData->AddLink(Edge(nv, deb, MeshDS_Free, theDomain));
	ne3=MeshData->AddLink(Edge(fin, nv, MeshDS_Free, theDomain));
	nt=MeshData->AddElement(Triangle(Abs(ne1), itFE.Key(), Abs(ne3), 
					 (ne1>0), sens, (ne3>0),
					 MeshDS_Free, theDomain));

	if (!tCircles.Add(theVertex.Coord(), 
			  debVert.Coord(), 
			  finVert.Coord(), nt))
	  MeshData->RemoveElement(nt);
      }
      else {

	if (sens) EdgLoop.Append(itFE.Key());
	else      EdgLoop.Append(-itFE.Key());
	if (vl1.SquareModulus()>vl3.SquareModulus()) {
	  ne1=MeshData->AddLink(Edge(nv, deb, MeshDS_Free, theDomain));
	  EdgExter.Append(Abs(ne1));
	}
	else{
	  ne3=MeshData->AddLink(Edge(fin, nv, MeshDS_Free, theDomain));
	  EdgExter.Append(Abs(ne3));
	}
      }
    }
#ifdef TRIANGULATION_DEBUG
    else {
      if (Triangulation_Trace>0)
	cout << " CreateTriangles : produit vectoriel trop petit !" << endl;
    }
#endif
  }
  theEdges.Clear();
  while (!EdgExter.IsEmpty()) {
    const ListOfInteger& conx=MeshData->ElemConnectedTo(Abs(EdgExter.First()));
    if (!conx.IsEmpty())
      DeleteTriangle(conx.First(), theEdges);
    EdgExter.RemoveFirst();
  }

  for (itFE.Initialize(theEdges); itFE.More(); itFE.Next()) {
    if (MeshData->ElemConnectedTo(itFE.Key()).IsEmpty())
      MeshData->RemoveLink(itFE.Key());
  }

  while (!EdgLoop.IsEmpty()) {
    if (GetEdge(Abs(EdgLoop.First())).Movability()!=MeshDS_Deleted) {
      MeshLeftPolygonOf(Abs(EdgLoop.First()), (EdgLoop.First()>0));
    }
    EdgLoop.RemoveFirst();
  }
}

//=======================================================================
//function : DeleteTriangle
//purpose : On détruit les triangles concernés  et on ajoute les edges
//          ainsi liberées dans <loopEdges>.  Si une edge est  ajoutée
//          deux  fois c'est qu elle n'éxistera plus   il faut donc la
//          détruire.  Cela   correspond   à  la  destruction  de deux
//          triangles connexes .
//=======================================================================

void  MeshAlgoAdapt_Delaunay::DeleteTriangle 
  (const Standard_Integer tIndex, TColStd_DataMapOfIntegerInteger& fEdges)
{
  tCircles.Delete(tIndex);

  Standard_Integer fe1, fe2, fe3;
  Standard_Boolean or1, or2, or3;
  GetTriangle(tIndex).Edges(fe1, fe2, fe3, or1, or2, or3);
  MeshData->RemoveElement(tIndex);

  if (!fEdges.Bind(fe1, or1)) {
    fEdges.UnBind(fe1);
    MeshData->RemoveLink(fe1);
  }
  if (!fEdges.Bind(fe2, or2))  {
    fEdges.UnBind(fe2);
    MeshData->RemoveLink(fe2);
  }
  if (!fEdges.Bind(fe3, or3))  {
    fEdges.UnBind(fe3);
    MeshData->RemoveLink(fe3);
  }

}


//=======================================================================
//function : AddVertex
//purpose  : 
//=======================================================================
void  MeshAlgoAdapt_Delaunay::AddVertex(const Vertex& theVert)
{
  Standard_DomainError_Raise_if(theVert.Domain()!=theDomain,
				"AddVertex : the Vertex is not on Domain!");
#ifdef DEB
  Standard_Integer nv=
#endif
    MeshData->AddNode(theVert);
  // Iterateur sur la liste des indices des cercles contenant le noeud :

  ListOfInteger& cirL=tCircles.Select(theVert.Coord());

  IteratorOnListOfInteger itT;
  Standard_Integer edgon=0;
  Standard_Integer triPer=0;
  Standard_Integer e1, e2, e3;
  Standard_Boolean o1, o2, o3;
  for (itT.Initialize(cirL); itT.More(); itT.Next()) {
    // Pour ajouter un noeud au maillage il faut verifier  conditions :
    // - le noeud doit etre dans les frontieres du maillage et donc
    //   dans un triangle existant
    // - tous les triangles touches doivent faire partie d une composante
    //   connexe de ce triangle
    if (Contains(itT.Value(), theVert, edgon)) {
      if (edgon==0) {
	triPer=itT.Value();
	cirL.Remove(itT);
	break;
      }
      else if (GetEdge(edgon).Movability()==MeshDS_Free) {
	triPer=itT.Value();
	cirL.Remove(itT);
	break;
      }
    }
  }

  if (triPer>0) {

    TColStd_DataMapOfIntegerInteger loopEdges;
    DeleteTriangle(triPer, loopEdges);

    Standard_Boolean modif=Standard_True;
    while (modif && !cirL.IsEmpty()) {
      modif=Standard_False;
      for (itT.Initialize(cirL); itT.More(); itT.Next()) {
	GetTriangle(itT.Value()).Edges(e1,e2,e3,o1,o2,o3);
	if (loopEdges.IsBound(e1) || 
	    loopEdges.IsBound(e2) || 
	    loopEdges.IsBound(e3)) {
	  modif=Standard_True;
	  DeleteTriangle(itT.Value(), loopEdges);
	  cirL.Remove(itT);
	  break;
	}
      }
    }

    // Création des triangles avec le node courant et les edges libres
    // et suppression de ces edges de la liste des edges libres :

    CreateTriangles(theVert, loopEdges);

  // Verification que les aretes internes ne sont pas traversees par des triangles.
    TColStd_MapIteratorOfMapOfInteger itFr(InternalEdges(theDomain));

//  Destruction des triangles interferant les arêtes internes et 
//  remplacement par des triangles ad-Hoc :

    Standard_Integer nbc;
    //IteratorOnListOfInteger itconx;
    itFr.Reset();
    for (; itFr.More(); itFr.Next()) {
      nbc = MeshData->ElemConnectedTo(itFr.Key()).Extent();
      if (nbc == 0) {
	MeshLeftPolygonOf(itFr.Key(), Standard_True); 
	MeshLeftPolygonOf(itFr.Key(), Standard_False); 
      }
    }

    FrontierAdjust();

  }

}

//=======================================================================
//function : RemoveVertex
//purpose  : 
//=======================================================================
void  MeshAlgoAdapt_Delaunay::RemoveVertex(const Vertex& theVert)
{
  Standard_DomainError_Raise_if(theVert.Domain()!=theDomain,
				"AddVertex : the Vertex is not on Domain!");

  MeshAlgoAdapt_SelectorOfDataStructure select(MeshData);
  select.NeighboursOf(theVert);

  TColStd_DataMapOfIntegerInteger loopEdges;

  // Boucle sur les triangles à détruire :
  TColStd_MapIteratorOfMapOfInteger trs(select.Elements());
  for (;trs.More(); trs.Next()) {
    DeleteTriangle(trs.Key(), loopEdges);
  }

  TColStd_SequenceOfInteger polyg;
  Standard_Integer iv;
  Standard_Integer nbLi=loopEdges.Extent();
  TColStd_DataMapIteratorOfDataMapOfIntegerInteger itFE(loopEdges);

  if (itFE.More()) {
    const Edge& edg=GetEdge(itFE.Key());
    Standard_Integer deb=edg.FirstNode();
    Standard_Integer fin;
    Standard_Integer pivo=edg.LastNode();
    Standard_Integer iseg=itFE.Key();
    Standard_Boolean sens=(Standard_Boolean)loopEdges(iseg);
    if (!sens) {
      iv=deb;
      deb=pivo;
      pivo=iv;
      polyg.Append(-iseg);
    }
    else {
      polyg.Append(iseg);
    }
    loopEdges.UnBind(iseg);
    fin=deb;
    IteratorOnListOfInteger itLiV;
    Standard_Integer vcur;
    while (pivo!=fin) {
      itLiV.Initialize(MeshData->LinkNeighboursOf(pivo));
      for (; itLiV.More(); itLiV.Next()) {
	if (itLiV.Value()!=iseg && loopEdges.IsBound(itLiV.Value())) {
	  iseg=itLiV.Value();
	  const Edge& edg=GetEdge(iseg);
	  vcur=edg.LastNode();
	  if (vcur!=pivo) {
	    vcur=edg.FirstNode();
	    polyg.Append(-iseg);
	  }
	  else
	    polyg.Append(iseg);
	  pivo=vcur;
	  loopEdges.UnBind(iseg);
	  break;
	}
      }
      if (nbLi<=0) break;
      nbLi--;
    }
    MeshPolygon(polyg);
  }
}


//=======================================================================
//function : AddVertices
//purpose  : 
//=======================================================================
void  MeshAlgoAdapt_Delaunay::AddVertices(MeshAlgoAdapt_Array1OfVertex& vertices)
{
  tCircles.unValid();

  MeshAlgoAdapt_HeapSortVertex::Sort
    (vertices, 
     MeshAlgoAdapt_ComparatorOfVertex(SortingDirection, Precision::PConfusion()));

  TColStd_DataMapOfIntegerInteger loopEdges;
  Standard_Boolean modif=Standard_True;
  IteratorOnListOfInteger itT;
  Standard_Integer edgon, triPer;
  Standard_Integer e1, e2, e3;
  Standard_Boolean o1, o2, o3;

  Standard_Integer niver;
  for (niver=vertices.Lower(); niver<=vertices.Upper(); niver++) {
    MeshData->AddNode(vertices(niver));

    // Iterateur sur la liste des indices des cercles contenant le noeud 
  
    ListOfInteger& cirL=tCircles.Select(vertices(niver).Coord());

    edgon=0;
    triPer=0;

    for (itT.Initialize(cirL); itT.More(); itT.Next()) {
      // Pour ajouter un noeud au maillage il faut verifier  conditions :
      // - le noeud doit etre dans les frontieres du maillage et donc
      //   dans un triangle existant
      // - tous les triangles touches doivent faire partie d une composante
      //   connexe de ce triangle
      if (Contains(itT.Value(), vertices(niver), edgon)) {
	if (edgon==0) {
	  triPer=itT.Value();
	  cirL.Remove(itT);
	  break;
	}
	else if (GetEdge(edgon).Movability()==MeshDS_Free) {
	  triPer=itT.Value();
	  cirL.Remove(itT);
	  break;
	}
      }
    }

    if (triPer>0) {
      DeleteTriangle(triPer, loopEdges);

      modif=Standard_True;
      while (modif && !cirL.IsEmpty()) {
	modif=Standard_False;
	for (itT.Initialize(cirL); itT.More(); itT.Next()) {
	  GetTriangle(itT.Value()).Edges(e1,e2,e3,o1,o2,o3);
	  if (loopEdges.IsBound(e1) || 
	      loopEdges.IsBound(e2) || 
	      loopEdges.IsBound(e3)) {
	    modif=Standard_True;
	    DeleteTriangle(itT.Value(), loopEdges);
	    cirL.Remove(itT);
	    break;
	  }
	}
      }

    // Création des triangles avec le node courant et les edges libres
    // et suppression de ces edges de la liste des edges libres :

      CreateTriangles(vertices(niver), loopEdges);
    }
  }

  // Verification que les aretes internes ne sont pas traversees par des triangles.
    TColStd_MapIteratorOfMapOfInteger itFr(InternalEdges(theDomain));

//  Destruction des triangles interferant les arêtes internes et 
//  remplacement par des triangles ad-Hoc :

    Standard_Integer nbc;
  //    IteratorOnListOfInteger itconx;
    itFr.Reset();
    for (; itFr.More(); itFr.Next()) {
      nbc = MeshData->ElemConnectedTo(itFr.Key()).Extent();
      if (nbc == 0) {
	MeshLeftPolygonOf(itFr.Key(), Standard_True); 
	MeshLeftPolygonOf(itFr.Key(), Standard_False); 
      }
    }


  // Ajustement des mailles aux aretes frontieres :
  FrontierAdjust();

  // Validation du circle tool. 
  tCircles.Valid();
}


//=======================================================================
//function : RevertDiagonal
//purpose  : 
//=======================================================================
Standard_Boolean MeshAlgoAdapt_Delaunay::RevertDiagonal(const Standard_Integer ind)
{
  const ListOfInteger& elConx=MeshData->ElemConnectedTo(ind);
  const Edge& lEdge = GetEdge(ind);
  if (elConx.Extent()==2 && lEdge.Movability()==MeshDS_Free) {
    Standard_Integer t1(elConx.First());
    Standard_Integer t2(elConx.Last());

    Standard_Integer e1t1, e2t1, e3t1, e1t2, e2t2, e3t2 ;
    Standard_Boolean o1t1, o2t1, o3t1, o1t2, o2t2, o3t2;
#ifndef DEB
    Standard_Integer ed13=0, ed23=0, ed14=0, ed24=0, v1, v2, v3=0, v4=0, vc1;
    Standard_Boolean oindt1=Standard_False, or13=Standard_False, 
    or23=Standard_False, or14=Standard_False, or24=Standard_False, orien;
#else
    Standard_Integer ed13, ed23, ed14, ed24, v1, v2, v3, v4, vc1;
    Standard_Boolean oindt1, or13, or23, or14, or24, orien;
#endif
    GetTriangle(t1).Edges(e1t1, e2t1, e3t1, o1t1, o2t1, o3t1);
    GetTriangle(t2).Edges(e1t2, e2t2, e3t2, o1t2, o2t2, o3t2);

    v1=lEdge.FirstNode(); v2=lEdge.LastNode();
    if      (e1t1==ind) {
      if (o2t1) v3 =GetEdge(e2t1).LastNode();
      else      v3 =GetEdge(e2t1).FirstNode();
      ed13=e3t1; ed23=e2t1;
      or13=o3t1; or23=o2t1;
      oindt1=o1t1;
    }
    else if (e2t1==ind) {
      if (o3t1) v3 =GetEdge(e3t1).LastNode();
      else      v3 =GetEdge(e3t1).FirstNode();
      ed13=e1t1; ed23=e3t1;
      or13=o1t1; or23=o3t1;
      oindt1=o2t1;
    }
    else if (e3t1==ind) {
      if (o1t1) v3 =GetEdge(e1t1).LastNode();
      else      v3 =GetEdge(e1t1).FirstNode();
      ed13=e2t1; ed23=e1t1;
      or13=o2t1; or23=o1t1;
      oindt1=o3t1;
    }
    if      (e1t2==ind) {
      if (o2t2) v4 =GetEdge(e2t2).LastNode();
      else      v4 =GetEdge(e2t2).FirstNode();
      ed14=e2t2; ed24=e3t2;
      or14=o2t2; or24=o3t2;
    }
    else if (e2t2==ind) {
      if (o3t2) v4 =GetEdge(e3t2).LastNode();
      else      v4 =GetEdge(e3t2).FirstNode();
      ed14=e3t2; ed24=e1t2;
      or14=o3t2; or24=o1t2;
    }
    else if (e3t2==ind) {
      if (o1t2) v4 =GetEdge(e1t2).LastNode();
      else      v4 =GetEdge(e1t2).FirstNode();
      ed14=e1t2; ed24=e2t2;
      or14=o1t2; or24=o2t2;
    }
    if (!oindt1) {
      vc1=v3; v3=v4; v4=vc1;
      vc1=ed13; ed13=ed24; ed24=vc1;
      orien =or13; or13=or24; or24=orien ;
      vc1=ed14; ed14=ed23; ed23=vc1;
      orien =or14; or14=or23; or23=orien ;
    }
    const Vertex& vert1 = GetVertex(v1);
    const Vertex& vert2 = GetVertex(v2);
    const Vertex& vert3 = GetVertex(v3);
    const Vertex& vert4 = GetVertex(v4);

    gp_XY ved13(vert1.Coord()); ved13.Subtract(vert3.Coord());
    gp_XY ved14(vert4.Coord()); ved14.Subtract(vert1.Coord());
    gp_XY ved23(vert3.Coord()); ved23.Subtract(vert2.Coord());
    gp_XY ved24(vert2.Coord()); ved24.Subtract(vert4.Coord());

    Standard_Real z13, z24, modul;
    z13=z24=0.;
    modul=ved13.Modulus();
    if (modul>Precision::PConfusion()) {
      ved13.SetCoord(ved13.X()/modul, ved13.Y()/modul);
      z13=ved13^ved14;
    }
    modul=ved24.Modulus();
    if (modul>Precision::PConfusion()) {
      ved24.SetCoord(ved24.X()/modul, ved24.Y()/modul);
      z24=ved24^ved23;
    }

    if (Abs(z13)>=Precision::PConfusion()&&Abs(z24)>=Precision::PConfusion()) {
      if ((z13>0. && z24>0.) || (z13<0. && z24<0.)) {
	tCircles.Delete(t1);
	tCircles.Delete(t2);
	if (!tCircles.Add(vert4.Coord(), vert2.Coord(), vert3.Coord(), t1) &&
	    !tCircles.Add(vert3.Coord(), vert1.Coord(), vert4.Coord(), t2)) {
	  Standard_Integer newd=ind;
	  Edge newEdg=Edge(v3, v4, MeshDS_Free, theDomain);
	  if (!MeshData->SubstituteLink(newd, newEdg)) {
	    newd=MeshData->IndexOf(newEdg);
	    MeshData->RemoveLink(ind);
	  }
	  MeshData->SubstituteElement(t1, Triangle(ed24, ed23, newd,
						   or24, or23, Standard_True,
						   MeshDS_Free, theDomain));
	  MeshData->SubstituteElement(t2, Triangle(ed13, ed14, newd,
						   or13, or14, Standard_False,
						   MeshDS_Free, theDomain));
	  return Standard_True;
	}
        else {
	  if (oindt1) {
	    tCircles.Add(vert1.Coord(), vert2.Coord(), vert3.Coord(), t1);
	    tCircles.Add(vert2.Coord(), vert1.Coord(), vert4.Coord(), t2);
	  }
	  else {
	    tCircles.Add(vert1.Coord(), vert2.Coord(), vert3.Coord(), t2);
	    tCircles.Add(vert2.Coord(), vert1.Coord(), vert4.Coord(), t1);
	  }
	}
      }
    }
  }
  return Standard_False;
}

//=======================================================================
//function : UseEdge
//purpose  : 
//=======================================================================
Standard_Boolean MeshAlgoAdapt_Delaunay::UseEdge(const Standard_Integer ind)
{
  const ListOfInteger& elConx=MeshData->ElemConnectedTo(ind);

  if (elConx.Extent()==0) {
    const Edge& lEdge = GetEdge(ind);
    Standard_Integer vdeb, pivo, othV, leftEdge, rightEdge;
    vdeb=lEdge.FirstNode();
    pivo=lEdge.LastNode();
    const ListOfInteger& neigVDeb = MeshData->LinkNeighboursOf(vdeb);
    const ListOfInteger& neigPivo = MeshData->LinkNeighboursOf(pivo);
    if (neigVDeb.Extent()>0 && neigPivo.Extent()>0) {
      const Vertex& vertDeb=GetVertex(vdeb);
      const Vertex& vertPivo=GetVertex(pivo);

      gp_XY vedcur;
      gp_XY vedge(vertPivo.Coord());
      vedge.Subtract(vertDeb.Coord());

      IteratorOnListOfInteger itNeig(neigPivo);
#ifndef DEB
      Standard_Real ang =0.;
#else
      Standard_Real ang;
#endif
      Standard_Real angMin=RealLast();
      Standard_Real angMax=RealFirst();
      Standard_Boolean InMesh;
      leftEdge=rightEdge=0;

      for (; itNeig.More(); itNeig.Next()) {
	if (itNeig.Value()!=ind) {
	  const Edge& nedg=GetEdge(itNeig.Value());

	  InMesh=Standard_True;
	  if (nedg.Movability()==MeshDS_Free) {
	    if (MeshData->ElemConnectedTo(itNeig.Value()).IsEmpty()) 
	      InMesh=Standard_False;
	  }

	  if (InMesh) {
	    othV=nedg.FirstNode();
	    if (othV==pivo) othV=nedg.LastNode();

	    vedcur=GetVertex(othV).Coord();
	    vedcur.Subtract(vertPivo.Coord());
	
	    ang=gp_Vec2d(vedge).Angle(gp_Vec2d(vedcur));
	  }
	  if (ang>angMax) {
	    angMax=ang;
	    leftEdge=itNeig.Value();
	  }
	  if (ang<angMin) {
	    angMin=ang;
	    rightEdge=itNeig.Value();
	  }
	}
      }
      if (leftEdge>0) {
	if (leftEdge==rightEdge) {
	}
	else {
	}
      }
    }
  }
  return Standard_False;
}

//=======================================================================
//function : SmoothMesh
//purpose  : 
//=======================================================================
void MeshAlgoAdapt_Delaunay::SmoothMesh(const Standard_Real Epsilon)
{
  Standard_Integer baryVert, polyVert, nbPolyVert;
  Standard_Real uSom, vSom, newU, newV;
  Standard_Integer nbVert=MeshData->NbNodes();
  IteratorOnListOfInteger itNeig;

  uSom=vSom=0;
  for (baryVert=1; baryVert<=nbVert; baryVert++) {
    const Vertex& curVert=GetVertex(baryVert);
    if (curVert.Movability()==MeshDS_Free) {
      const ListOfInteger& neighEdg=MeshData->LinkNeighboursOf(baryVert);
      if (neighEdg.Extent()>2) {
        nbPolyVert=0;
	for (itNeig.Initialize(neighEdg); itNeig.More(); itNeig.Next()) {
	  const Edge& nedg=GetEdge(itNeig.Value());
	  polyVert=nedg.FirstNode();
          if (polyVert==baryVert) polyVert=nedg.LastNode();
	  nbPolyVert++;
	  const gp_XY& pVal = GetVertex(polyVert).Coord();
	  uSom+=pVal.X();
	  vSom+=pVal.Y();
	}
	if (nbPolyVert>2) {
	  newU=uSom/(Standard_Real)nbPolyVert;
	  newV=vSom/(Standard_Real)nbPolyVert;
	  if (!curVert.Coord().IsEqual(gp_XY(newU, newV), Epsilon)) {
	    Vertex newVert(newU, newV, curVert.Domain(), curVert.Movability());
	    MeshData->MoveNode(baryVert, newVert);
	  }
	}
      }
    }
  }
}

//=======================================================================
//function : Result
//purpose  : 
//=======================================================================
const Handle(MeshAlgoAdapt_DataStructure)& MeshAlgoAdapt_Delaunay::Result()const
{
  return MeshData;
}

//=======================================================================
//function : Frontier
//purpose  : 
//=======================================================================
const TColStd_MapOfInteger& MeshAlgoAdapt_Delaunay::Frontier
  (const Standard_Integer domain)
{
  TColStd_MapIteratorOfMapOfInteger triDom(MeshData->LinkOfDomain(domain));

  mapEdges.Clear();
  for (; triDom.More(); triDom.Next()) {
    if (GetEdge(triDom.Key()).Movability()==MeshDS_Frontier) {
      mapEdges.Add(triDom.Key());
    }
  }
  return mapEdges;
}

//=======================================================================
//function : InternalEdges
//purpose  : 
//=======================================================================
const TColStd_MapOfInteger& MeshAlgoAdapt_Delaunay::InternalEdges 
  (const Standard_Integer domain)
{
  TColStd_MapIteratorOfMapOfInteger triDom(MeshData->LinkOfDomain(domain));

  mapEdges.Clear();
  for (; triDom.More(); triDom.Next()) {
    if (GetEdge(triDom.Key()).Movability()==MeshDS_Fixed) {
      mapEdges.Add(triDom.Key());
    }
  }
  return mapEdges;
}

//=======================================================================
//function : FreeEdges
//purpose  : 
//=======================================================================
const TColStd_MapOfInteger& MeshAlgoAdapt_Delaunay::FreeEdges
  (const Standard_Integer domain)
{
  TColStd_MapIteratorOfMapOfInteger triDom(MeshData->LinkOfDomain(domain));

  mapEdges.Clear();
  for (; triDom.More(); triDom.Next()) {
    if (MeshData->ElemConnectedTo(triDom.Key()).Extent()<=1) {
      mapEdges.Add(triDom.Key());
    }
  }
  return mapEdges;
}


//=======================================================================
//function : Contains
//purpose  : 
//=======================================================================
Standard_Boolean MeshAlgoAdapt_Delaunay::Contains(const Standard_Integer tri,
						  const Vertex& vert,
						  Standard_Integer& edgOn)const
{
  edgOn=0;
  Standard_Integer e1, e2, e3, p1, p2, p3;
  Standard_Boolean o1, o2, o3;
  GetTriangle(tri).Edges(e1, e2, e3, o1, o2, o3);
  const Edge& edg1=GetEdge(e1);
  const Edge& edg2=GetEdge(e2);
  const Edge& edg3=GetEdge(e3);
  if (o1) {
    p1=edg1.FirstNode();
    p2=edg1.LastNode();
  }
  else {
    p2=edg1.FirstNode();
    p1=edg1.LastNode();
  }
  if (o3) p3=edg3.FirstNode();
  else    p3=edg3.LastNode();

  const gp_XY& P1=GetVertex(p1).Coord();
  const gp_XY& P2=GetVertex(p2).Coord();
  const gp_XY& P3=GetVertex(p3).Coord();
  gp_XY E1(P2); E1.Subtract(P1);
  gp_XY E2(P3); E2.Subtract(P2);
  gp_XY E3(P1); E3.Subtract(P3);

  Standard_Real mode1=E1.SquareModulus();
  Standard_Real dist=Sqrt(mode1);
  if (dist<=Precision::PConfusion()) return Standard_False;
  Standard_Real v1=E1^(vert.Coord()-P1);
  Standard_Real distMin=v1/dist;
  edgOn=e1;

  Standard_Real mode2=E2.SquareModulus();
  dist=Sqrt(mode2);
  if (dist<=Precision::PConfusion()) return Standard_False;
  Standard_Real v2=E2^(vert.Coord()-P2);
  dist=v2/dist;
  if (dist<distMin) {
    edgOn=e2;
    distMin=dist;
  }

  Standard_Real mode3=E3.SquareModulus();
  dist=Sqrt(mode3);
  if (dist<=Precision::PConfusion()) return Standard_False;
  Standard_Real v3=E3^(vert.Coord()-P3);
  dist=v3/dist;
  if (dist<distMin) {
    edgOn=e3;
    distMin=dist;
  }

  if (distMin>Precision::PConfusion()) {
    Standard_Integer edf=edgOn;
    edgOn=0;
    if      (edf==e1 && edg1.Movability()!=MeshDS_Free) {
      if (v1<(mode1/5.)) edgOn=e1;
    }
    else if (edf==e2 && edg2.Movability()!=MeshDS_Free) {
      if (v2<(mode2/5.)) edgOn=e2;
    }
    else if (edf==e3 && edg3.Movability()!=MeshDS_Free) {
      if (v3<(mode3/5.)) edgOn=e3;
    }
  }

/*  
  Standard_Integer edf=edgOn;
  edgOn=0;
  if      (edf==e1 && edg1.Movability()!=MeshDS_Free) {
    if (v1<(mode1/5.)) edgOn=e1;
  }
  else if (edf==e2 && edg2.Movability()!=MeshDS_Free) {
    if (v2<(mode2/5.)) edgOn=e2;
  }
  else if (edf==e3 && edg3.Movability()!=MeshDS_Free) {
    if (v3<(mode3/5.)) edgOn=e3;
  }
  else if (distMin>Precision::PConfusion()) {
    edgOn=edf;
  }
*/

  return (v1+v2+v3!=0. &&((v1>=0. && v2>=0. && v3>=0.) ||
			  (v1<=0. && v2<=0. && v3<=0.)));
}

//=======================================================================
//function : TriangleContaining
//purpose  : 
//=======================================================================
Standard_Integer MeshAlgoAdapt_Delaunay::TriangleContaining(const Vertex& vert)
{
  const ListOfInteger& cirL=tCircles.Select(vert.Coord());

  IteratorOnListOfInteger itT;
  Standard_Integer triPer=0;
  Standard_Integer edgon=0;
  for (itT.Initialize(cirL); itT.More(); itT.Next()) {
    if (Contains(itT.Value(), vert, edgon)) {
      if (edgon==0) {
	triPer=itT.Value();
	break;
      }
      else if (GetEdge(edgon).Movability()==MeshDS_Free) {
	triPer=itT.Value();
	break;
      }
    }
  }
  return triPer;
}
