// File generated by CPPExt (Transient)
//
//                     Copyright (C) 1991,1995 by
//  
//                      MATRA DATAVISION, FRANCE
//  
// This software is furnished in accordance with the terms and conditions
// of the contract and with the inclusion of the above copyright notice.
// This software or any other copy thereof may not be provided or otherwise
// be made available to any other person. No title to an ownership of the
// software is hereby transferred.
//  
// At the termination of the contract, the software and all copies of this
// software must be deleted.
//
#ifndef _TDataStd_Name_HeaderFile
#define _TDataStd_Name_HeaderFile

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Handle_TDataStd_Name_HeaderFile
#include <Handle_TDataStd_Name.hxx>
#endif

#include <TCollection_ExtendedString.hxx>
#include <TDF_Attribute.hxx>
#include <Handle_TDF_Attribute.hxx>
#include <Handle_TDF_RelocationTable.hxx>
#include <Standard_OStream.hxx>
class Standard_DomainError;
class Standard_GUID;
class TDF_Label;
class TCollection_ExtendedString;
class TDF_Attribute;
class TDF_RelocationTable;

#ifndef _Standard_Macro_HeaderFile
#include <Standard_Macro.hxx>
#endif
#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif

#ifndef _Handle_TDF_Attribute_HeaderFile
#include <Handle_TDF_Attribute.hxx>
#endif

class Standard_Transient;
class Handle_Standard_Type;
class Handle(TDF_Attribute);
class TDataStd_Name;
Standard_EXPORT Handle_Standard_Type& STANDARD_TYPE(TDataStd_Name);

/** Handle class for FCAttribute
 */
class DocExport Handle_FCAttribute :public Handle(TDF_Attribute) 
{
public:
	void* operator new(size_t,void* anAddress){return anAddress;}
	void* operator new(size_t size){return Standard::Allocate(size);}
	void  operator delete(void *anAddress){if (anAddress) Standard::Free((Standard_Address&)anAddress);}
	Handle_FCAttribute():Handle(TDF_Attribute)() {} 
	Handle_FCAttribute(const Handle(TDataStd_Name)& aHandle) : Handle(TDF_Attribute)(aHandle){}

	Handle_FCAttribute(const TDataStd_Name* anItem) : Handle(TDF_Attribute)((TDF_Attribute *)anItem){}

	Handle_FCAttribute& operator=(const Handle(TDataStd_Name)& aHandle)
	{
		Assign(aHandle.Access());
		return *this;
	}

	Handle_FCAttribute& operator=(const TDataStd_Name* anItem)
	{
		Assign((Standard_Transient *)anItem);
		return *this;
	}

	TDataStd_Name* operator->() 
	{
		return (FCAttribute *)ControlAccess();
	}

	TDataStd_Name* operator->() const{return (FCAttribute *)ControlAccess();}
	~Handle_FCAttribute();
	static const Handle_FCAttribute DownCast(const Handle(Standard_Transient)& AnObject);
};



class DocExport FCAttribute : public TDF_Attribute {

public:

	/// Constructor
	FCAttribute();
	/// Destructor
	~FCAttribute();

	/// Delivers the GUID of the Object
	static const Standard_GUID& GetID() ;


	/// Saving to a stream
	virtual  Standard_OStream& Dump(Standard_OStream& anOS) const;

	/// copy
	void Restore(const Handle(TDF_Attribute)& with) ;

	/// Set data
	void Set(const TCollection_ExtendedString& S) ;
	/// Get data
	TCollection_ExtendedString Get() const;

	/// not shure
	static  Handle_TDataStd_Name Set(const TDF_Label& label,const TCollection_ExtendedString& string) ;

	/// Get the unique ID of the Attribute
	const Standard_GUID& ID() const;

	/// Get a empty instance
	Handle_TDF_Attribute NewEmpty() const;

	/// some kind of pasting ???
	void Paste(const Handle(TDF_Attribute)& into,const Handle(TDF_RelocationTable)& RT) const;


	/// needet for CasCade handles 
    void* operator new(size_t,void* anAddress)	{return anAddress;}
    void* operator new(size_t size)				{return Standard::Allocate(size);}
    void  operator delete(void *anAddress)		{if (anAddress) Standard::Free((Standard_Address&)anAddress);}
	friend Handle_Standard_Type& TDataStd_Name_Type_();
	const Handle(Standard_Type)& DynamicType() const;
	Standard_Boolean	       IsKind(const Handle(Standard_Type)&) const;

private: 

	/// Data member string
	TCollection_ExtendedString myString;

};




#endif
